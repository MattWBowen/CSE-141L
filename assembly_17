r0 = accumulator
r1 = 
r2 = operand 1
r3 = 
r4 = operand 2
r5 = s1
r6 = s2
r7 = s3
r8 = s4
r9 =                /sign_a
r10= loop counter   /sign_b
r11= isNeg          /
r12= sum_high           
r13= sum_low
r14= partial_high
r15= partial_low    
*r16 = overlow_bit (1 bit register)



    //load operand a1,a2,b1,b2
    takei #1
    load r0
    put r1      //r1=a1

    takei #2
    load r0
    put r2      //r2=a2

    takei #3
    load r0
    put r3      //r3=b1

    takei #4
    load r0
    put r4      //r4=b2

    //declare sign_a, sign_b
    take a1
    shr #7
    put r9      //sign_a = r9

    take b1
    shr #7
    put r10     //sign_b = r10


    /* complex condition unrolling
    if((r9==1 && r10==0) || (r9==0 && r10==1))

    isNeg=0
    if(r9==1)
    {
        if(r10==0)
            isNeg=1;
    }
    if(all==0)
    {
        if(r9==0)
        {
            if(r10==1)
                isNeg=1;
        }
    }
    */

    takei #0
    put r11         //isNeg=0
    takei #1        //acc=1
    eql r9          //check if r9==1, if yes, acc=1
    b0 S_1
    takei #0
    eql r10
    b0 S_1
    takei #1
    put r11         //isNeg=1
S_1:
    takei #0
    eql r11
    b0 S_2
    takei #0
    eql r9
    b0 S_2
    takei #1
    b0 S_2
    put r11         //implicitly have r11(isNeg)=1
S_2:

    //do 2's complement on A and B
    //r1=a1, r2=a2, r3=b1, r4=b2
    //check if r9(sign_a)==1, if yes, a1<0
    takei #1
    eql r9
    b0 S_3
    take r1
    neg
    put r1
    take r2
    neg             //TODO: add negate instruction
    put r2
    take #-1
    b0 S_4
    takei #0        //a2=0;
    put r2          //a1=a1+1;
    takei #1
    add r1
    put r1
    takei #0        //jump over the else case
    b0 S_3
S_4:
    takei #1        //a2=a2+1
    add r2
    put r2
S_3:

    //r1=a1, r2=a2, r3=b1, r4=b2
    //check if r10(sign_b)==1, if yes, b1<0
    takei #1
    eql r10
    b0 S_3
    take r3
    neg
    put r3
    take r4
    neg             //TODO: add negate instruction
    put r4
    take #-1
    b0 S_6
    takei #0        //b2=0; (r4)
    put r4          //b1=b1+1;
    takei #1
    add r3
    put r3
    takei #0        //jump over the else case
    b0 S_5
S_6:
    takei #1        //b2=b2+1
    add r4
    put r4
S_5:

    //set s1~s4=0
    takei #0
    put r5
    put r6
    put r7
    put r8


    //a2xb2 (r2xr4)--------------------------------
    //reset partial sum to zero
    put r12
    put r13
    put r14
    put r15

    put r10         //i=0
A2B2:
    
    //mask=1 << i
    takei #1
    shl r10
    and r4      //acc = b_bit = b2 & mask

    b0 A2B2_S
    take r2
    shl r10
    put r15     //save partial_low

    takei #8
    sub r10     //8-i
    put r9
    take r2
    shr r9      //a2>>8-i
    put r14     //save partial_high

    of0         //set overlow_bit to zero
    take r13
    add r15
    put r13     //sum_low = sum_low + partial_low

    take r12
    add r14
    add r16     //add overflow bit register
    put r12
A2B2_S:
    //check counter at the end of loop
    takei #1
    add r10
    put r10
    takei #8
    put r9          //r9 is the upper limit of loop
    lsn r9
    b0 A2B2

    //s3 = s3 + sum_high = r7 + r12
    //s4 = s4 + sum_low = r8 + r13
    take r7
    add r12
    put r12
    take r8
    add r13
    put r13
    
    //a1xb2 (r1xr4)--------------------------------
    //reset partial sum to zero
    take #0
    put r12
    put r13
    put r14
    put r15

    put r10         //i=0
A1B2:
    
    //mask=1 << i
    takei #1
    shl r10
    and r4      //acc = b_bit = b2 & mask

    b0 A1B2_S
    take r1
    shl r10
    put r15     //save partial_low

    takei #8
    sub r10     //8-i
    put r9
    take r1
    shr r9      //a1>>8-i
    put r14     //save partial_high

    of0         //set overlow_bit to zero
    take r13
    add r15
    put r13     //sum_low = sum_low + partial_low

    take r12
    add r14
    add r16     //add overflow bit register
    put r12
A1B2_S:
    //check counter at the end of loop
    takei #1
    add r10
    put r10
    takei #8
    put r9          //r9 is the upper limit of loop
    lsn r9
    b0 A1B2

    //s2(r6) = s2 + sum_high = r6 + r12 (of)
    //s3(r7) = s3 + sum_low = r7 + r13 (of)
    of0
    take r7
    add r13
    put r13
    take r16
    b0 A1B2_OF_1    //if(s3_overflow)?
    of0
    takei #1
    add r6
    put r6          //if of, s2+=1
    take r16
    b0 A1B2_OF_2    //if adding one to s2 cause of?
    of0
    takei #1
    add r5
    put r5          //s1 = s1 + 1

A1B2_OF_2:
A1B2_OF_1:

    of0
    take r6
    add r12
    put r12
    take r16
    b0 A1B2_OF_3
    takei #1
    add r5
    put r5          //s1 += 1

A1B2_OF_3:



//have not modified yet
    //a2xb2 (r2xr4)--------------------------------
    //reset partial sum to zero
    put r12
    put r13
    put r14
    put r15

    put r10         //i=0
A2B2:
    
    //mask=1 << i
    takei #1
    shl r10
    and r4      //acc = b_bit = b2 & mask

    b0 A2B2_S
    take r2
    shl r10
    put r15     //save partial_low

    takei #8
    sub r10     //8-i
    put r9
    take r2
    shr r9      //a2>>8-i
    put r14     //save partial_high

    of0         //set overlow_bit to zero
    take r13
    add r15
    put r13     //sum_low = sum_low + partial_low

    take r12
    add r14
    add r16     //add overflow bit register
    put r12
A2B2_S:
    //check counter at the end of loop
    takei #1
    add r10
    put r10
    takei #8
    put r9          //r9 is the upper limit of loop
    lsn r9
    b0 A2B2

    //s3 = s3 + sum_high = r7 + r12
    //s4 = s4 + sum_low = r8 + r13
    take r7
    add r12
    put r12
    take r8
    add r13
    put r13
    
    //a1xb2 (r1xr4)--------------------------------
    //reset partial sum to zero
    take #0
    put r12
    put r13
    put r14
    put r15

    put r10         //i=0
A1B2:
    
    //mask=1 << i
    takei #1
    shl r10
    and r4      //acc = b_bit = b2 & mask

    b0 A1B2_S
    take r1
    shl r10
    put r15     //save partial_low

    takei #8
    sub r10     //8-i
    put r9
    take r1
    shr r9      //a1>>8-i
    put r14     //save partial_high

    of0         //set overlow_bit to zero
    take r13
    add r15
    put r13     //sum_low = sum_low + partial_low

    take r12
    add r14
    add r16     //add overflow bit register
    put r12
A1B2_S:
    //check counter at the end of loop
    takei #1
    add r10
    put r10
    takei #8
    put r9          //r9 is the upper limit of loop
    lsn r9
    b0 A1B2

    //s2(r6) = s2 + sum_high = r6 + r12 (of)
    //s3(r7) = s3 + sum_low = r7 + r13 (of)
    of0
    take r7
    add r13
    put r13
    take r16
    b0 A1B2_OF_1    //if(s3_overflow)?
    of0
    takei #1
    add r6
    put r6          //if of, s2+=1
    take r16
    b0 A1B2_OF_2    //if adding one to s2 cause of?
    of0
    takei #1
    add r5
    put r5          //s1 = s1 + 1

A1B2_OF_2:
A1B2_OF_1:

    of0
    take r6
    add r12
    put r12
    take r16
    b0 A1B2_OF_3
    takei #1
    add r5
    put r5          //s1 += 1

A1B2_OF_3:



